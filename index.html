<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QCM sur l'Intelligence Artificielle</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        .quiz-container {
            background-color: #fff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        .question {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f9f9f9;
            display: none;
        }
        .question.active {
            display: block;
        }
        .options {
            margin-top: 10px;
        }
        .option {
            display: block;
            margin: 10px 0;
            padding: 10px;
            background-color: #e8f4f8;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .option:hover {
            background-color: #d0e8f2;
        }
        .option.selected {
            background-color: #3498db;
            color: white;
        }
        .option.correct {
            background-color: #2ecc71;
            color: white;
        }
        .option.incorrect {
            background-color: #e74c3c;
            color: white;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .progress-container {
            width: 100%;
            height: 10px;
            background-color: #ddd;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .progress-bar {
            height: 100%;
            background-color: #3498db;
            border-radius: 5px;
            width: 0%;
            transition: width 0.5s;
        }
        .results {
            text-align: center;
            display: none;
        }
        .restart-btn {
            display: block;
            margin: 20px auto;
        }
        .explanation {
            margin-top: 15px;
            padding: 15px;
            background-color: #f0f8ff;
            border-left: 4px solid #3498db;
            display: none;
        }
        .code {
            font-family: monospace;
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>QCM sur l'Intelligence Artificielle</h1>
    <div class="progress-container">
        <div class="progress-bar" id="progress"></div>
    </div>
    <div class="quiz-container" id="quiz">
        <div id="question-container"></div>
        <div class="feedback" id="feedback"></div>
        <div class="explanation" id="explanation"></div>
        <div class="controls">
            <button id="prev-btn" disabled>Pr√©c√©dent</button>
            <button id="check-btn">V√©rifier</button>
            <button id="next-btn" disabled>Suivant</button>
        </div>
    </div>
    <div class="results" id="results">
        <h2>R√©sultats</h2>
        <p id="score-display"></p>
        <p id="score-message"></p>
        <button class="restart-btn" id="restart-btn">Recommencer le quiz</button>
    </div>

    <script>
        // Questions du QCM
        const questions = [
            {
                question: "Dans quelle situation l'utilisation d'un r√©seau de neurones r√©current (RNN) est-elle plus appropri√©e qu'un CNN ?",
                options: [
                    "Pour l'analyse d'images satellites",
                    "Pour le traitement de s√©quences temporelles comme les s√©ries chronologiques ou le texte",
                    "Pour la classification d'images m√©dicales",
                    "Pour la segmentation s√©mantique d'images"
                ],
                correctIndex: 1,
                explanation: "Les RNN sont sp√©cialement con√ßus pour traiter des donn√©es s√©quentielles o√π l'ordre temporel est important, comme le texte, les s√©ries temporelles ou l'audio. Ils poss√®dent des connexions r√©currentes qui permettent de maintenir un √©tat interne (m√©moire) capturant les d√©pendances temporelles. Les CNN, en revanche, excellent dans l'extraction de caract√©ristiques spatiales locales et hi√©rarchiques dans des donn√©es avec une structure en grille, comme les images."
            },
            {
                question: "Quelle est la diff√©rence fondamentale entre les op√©rations de pooling et de convolution dans un CNN ?",
                options: [
                    "Le pooling extrait des caract√©ristiques, tandis que la convolution r√©duit la dimensionnalit√©",
                    "Le pooling applique une fonction non-lin√©aire, tandis que la convolution est toujours lin√©aire",
                    "La convolution extrait des caract√©ristiques via des filtres apprenables, tandis que le pooling r√©duit la dimensionnalit√© sans param√®tres apprenables",
                    "La convolution fonctionne uniquement sur les images en niveaux de gris, tandis que le pooling fonctionne sur les images couleur"
                ],
                correctIndex: 2,
                explanation: "La convolution utilise des filtres avec des poids apprenables pour extraire des caract√©ristiques sp√©cifiques (comme des contours, textures, etc.) en effectuant une op√©ration de produit scalaire entre le filtre et les r√©gions de l'entr√©e. Le pooling, en revanche, est une op√©ration de sous-√©chantillonnage sans param√®tres apprenables qui r√©duit la dimensionnalit√© spatiale en agr√©geant l'information localement (par exemple, en prenant le maximum ou la moyenne d'une r√©gion)."
            },
            {
                question: "Dans l'algorithme AdaBoost, comment sont pond√©r√©s les √©chantillons apr√®s chaque it√©ration ?",
                options: [
                    "Les poids de tous les √©chantillons sont uniform√©ment diminu√©s",
                    "Les poids des √©chantillons correctement classifi√©s sont augment√©s, ceux mal classifi√©s sont diminu√©s",
                    "Les poids des √©chantillons correctement classifi√©s sont diminu√©s, ceux mal classifi√©s sont augment√©s",
                    "Les poids restent constants, seuls les poids des classificateurs faibles changent"
                ],
                correctIndex: 2,
                explanation: "Dans AdaBoost, apr√®s chaque it√©ration, les poids des √©chantillons correctement classifi√©s sont diminu√©s tandis que ceux des √©chantillons mal classifi√©s sont augment√©s. Cela force les classificateurs faibles suivants √† se concentrer davantage sur les exemples difficiles (mal classifi√©s), am√©liorant ainsi progressivement la performance de l'ensemble. La formule math√©matique utilis√©e est Dt+1(i) = Dt(i) √ó exp(-Œ±t √ó yi √ó ht(xi)) o√π Œ±t est le poids du classificateur, yi est l'√©tiquette r√©elle et ht(xi) est la pr√©diction."
            },
            {
                question: "Quelles techniques permettent de r√©soudre efficacement le probl√®me d'explosion du gradient dans les RNN ?",
                options: [
                    "L'augmentation du taux d'apprentissage et l'utilisation d'un plus grand nombre de couches",
                    "L'utilisation exclusive de fonctions d'activation lin√©aires",
                    "L'√©cr√™tage du gradient (gradient clipping) et l'utilisation d'architectures comme LSTM ou GRU",
                    "Le sur√©chantillonnage des donn√©es d'entra√Ænement et la normalisation par lots"
                ],
                correctIndex: 2,
                explanation: "L'explosion du gradient est particuli√®rement probl√©matique dans les RNN profonds. Deux principales solutions sont : (1) l'√©cr√™tage du gradient (gradient clipping) qui limite la norme du gradient √† un seuil maximum, emp√™chant ainsi des mises √† jour trop importantes, et (2) l'utilisation d'architectures sp√©ciales comme LSTM (Long Short-Term Memory) ou GRU (Gated Recurrent Unit) qui sont con√ßues avec des m√©canismes de portes pour mieux contr√¥ler le flux du gradient √† travers le temps."
            },
            {
                question: "Pourquoi RMSE (Root Mean Squared Error) est-elle souvent pr√©f√©r√©e √† MSE comme m√©trique d'√©valuation ?",
                options: [
                    "RMSE est toujours plus petite que MSE, donc plus facile √† interpr√©ter",
                    "RMSE est exprim√©e dans la m√™me unit√© que la variable cible, ce qui facilite l'interpr√©tation",
                    "RMSE est moins sensible aux valeurs aberrantes que MSE",
                    "RMSE converge plus rapidement que MSE lors de l'optimisation"
                ],
                correctIndex: 1,
                explanation: "RMSE est la racine carr√©e de MSE (RMSE = ‚àöMSE). Son principal avantage est qu'elle est exprim√©e dans la m√™me unit√© que la variable pr√©dite, ce qui facilite l'interpr√©tation des erreurs. Par exemple, si on pr√©dit des prix en euros, MSE serait en euros¬≤, tandis que RMSE serait en euros. Math√©matiquement, les deux m√©triques sont monotoniquement li√©es, donc minimiser l'une revient √† minimiser l'autre."
            },
            {
                question: "Quelle fonction de co√ªt est la plus appropri√©e pour un probl√®me de classification binaire et pourquoi ?",
                options: [
                    "MSE (Mean Squared Error), car elle p√©nalise plus fortement les erreurs importantes",
                    "MAE (Mean Absolute Error), car elle est plus robuste aux valeurs aberrantes",
                    "Entropie crois√©e binaire (Binary Cross-Entropy), car elle est sp√©cifiquement con√ßue pour les probabilit√©s et p√©nalise fortement les pr√©dictions confiantes mais incorrectes",
                    "L'erreur de Poisson, car elle est adapt√©e aux distributions binomiales"
                ],
                correctIndex: 2,
                explanation: "L'entropie crois√©e binaire (BCE) est la fonction de co√ªt la plus adapt√©e pour la classification binaire car elle mesure la divergence entre deux distributions de probabilit√© : les √©tiquettes r√©elles et les pr√©dictions. Math√©matiquement, elle est d√©finie comme BCE = -Œ£[y_i * log(p_i) + (1-y_i) * log(1-p_i)]. Sa principale force est qu'elle p√©nalise tr√®s fortement les pr√©dictions confiantes mais incorrectes (ex. pr√©dire 0.01 quand la vraie valeur est 1), ce qui incite le mod√®le √† √™tre prudent dans ses pr√©dictions."
            },
            {
                question: "Comment XGBoost g√®re-t-il les probl√®mes de surapprentissage par rapport √† un algorithme de boosting standard comme AdaBoost ?",
                options: [
                    "XGBoost n'impl√©mente aucune r√©gularisation, il n√©cessite un √©lagage manuel des arbres",
                    "XGBoost utilise uniquement un sous-√©chantillonnage des donn√©es pour √©viter le surapprentissage",
                    "XGBoost int√®gre une r√©gularisation dans sa fonction objectif en p√©nalisant la complexit√© des arbres via le nombre de feuilles et la magnitude des poids",
                    "XGBoost √©vite le surapprentissage uniquement en limitant le nombre d'it√©rations"
                ],
                correctIndex: 2,
                explanation: "XGBoost int√®gre explicitement la r√©gularisation dans sa fonction objectif, contrairement aux algorithmes de boosting traditionnels. Sa fonction objectif inclut un terme de perte (erreur d'entra√Ænement) et un terme de r√©gularisation Œ©(f) qui p√©nalise la complexit√© du mod√®le. Ce terme de r√©gularisation est d√©fini comme Œ©(f) = Œ≥T + Œª‚àëw¬≤ o√π T est le nombre de feuilles, w repr√©sente les poids des feuilles, Œ≥ et Œª sont des hyperparam√®tres de r√©gularisation. En plus, XGBoost impl√©mente d'autres techniques comme le sous-√©chantillonnage des lignes/colonnes et l'arr√™t pr√©coce."
            },
            {
                question: "Quelle est la signification g√©om√©trique du param√®tre C dans les SVM √† marges souples (Soft Margin SVM) ?",
                options: [
                    "C d√©finit la distance minimale entre l'hyperplan et les vecteurs de support",
                    "C contr√¥le le compromis entre la maximisation de la marge et la minimisation de l'erreur de classification",
                    "C d√©termine le nombre maximum de vecteurs de support autoris√©s",
                    "C sp√©cifie la dimension du noyau utilis√© pour la projection"
                ],
                correctIndex: 1,
                explanation: "Dans les SVM √† marges souples, le param√®tre C contr√¥le le compromis entre deux objectifs contradictoires : maximiser la marge (qui favorise la g√©n√©ralisation) et minimiser l'erreur de classification sur les donn√©es d'entra√Ænement. Math√©matiquement, le probl√®me d'optimisation devient : min(w,b) (1/2)||w||¬≤ + C‚àëŒæ·µ¢, o√π Œæ·µ¢ sont les variables d'√©cart qui permettent des violations de la marge. Un C faible permet plus de violations (marge plus large, plus d'erreurs), tandis qu'un C √©lev√© p√©nalise davantage les erreurs (marge plus √©troite, moins d'erreurs)."
            },
            {
                question: "Quelle diff√©rence fondamentale existe entre le Bagging (utilis√© dans Random Forest) et le Boosting (utilis√© dans AdaBoost, XGBoost) ?",
                options: [
                    "Le Bagging construit des mod√®les s√©quentiellement, tandis que le Boosting les construit en parall√®le",
                    "Le Bagging utilise uniquement des arbres de d√©cision, tandis que le Boosting peut utiliser n'importe quel type de mod√®le",
                    "Le Bagging entra√Æne chaque mod√®le sur un sous-ensemble al√©atoire des donn√©es, tandis que le Boosting entra√Æne chaque mod√®le pour corriger les erreurs des mod√®les pr√©c√©dents",
                    "Le Bagging n√©cessite beaucoup plus de mod√®les que le Boosting pour atteindre des performances similaires"
                ],
                correctIndex: 2,
                explanation: "La diff√©rence essentielle est dans la mani√®re dont les mod√®les de base sont entra√Æn√©s et combin√©s. Dans le Bagging (Bootstrap Aggregating), chaque mod√®le est entra√Æn√© ind√©pendamment sur un √©chantillon bootstrap des donn√©es, puis les pr√©dictions sont combin√©es par vote majoritaire ou moyenne. Dans le Boosting, les mod√®les sont entra√Æn√©s s√©quentiellement, chaque nouveau mod√®le se concentrant sur les erreurs des mod√®les pr√©c√©dents. Cette d√©pendance s√©quentielle est fondamentale : les poids des √©chantillons ou les r√©sidus sont ajust√©s apr√®s chaque it√©ration pour que les mod√®les suivants se focalisent sur les cas difficiles."
            },
            {
                question: "Comment la r√©gularisation Ridge affecte-t-elle un mod√®le lin√©aire sujet au probl√®me de multicolin√©arit√© par rapport √† une r√©gression lin√©aire standard ?",
                options: [
                    "Ridge n'a aucun effet sur la multicolin√©arit√©, elle r√©duit uniquement le surapprentissage",
                    "Ridge √©limine compl√®tement les variables redondantes en mettant leurs coefficients √† z√©ro",
                    "Ridge distribue les coefficients entre les variables corr√©l√©es au lieu d'attribuer un coefficient √©lev√© √† une seule variable",
                    "Ridge augmente automatiquement les coefficients des variables les plus informatives"
                ],
                correctIndex: 2,
                explanation: "La multicolin√©arit√© (forte corr√©lation entre pr√©dicteurs) pose probl√®me dans la r√©gression lin√©aire standard car elle peut conduire √† des coefficients instables et de grande magnitude. La r√©gularisation Ridge ajoute une p√©nalit√© L2 (somme des carr√©s des coefficients) √† la fonction objectif, ce qui a pour effet de r√©tr√©cir tous les coefficients vers z√©ro, mais sans jamais les annuler compl√®tement. Pour des variables fortement corr√©l√©es, Ridge tend √† distribuer le poids entre elles de mani√®re plus √©quilibr√©e, au lieu d'attribuer un coefficient tr√®s √©lev√© √† l'une et tr√®s faible √† l'autre, comme pourrait le faire la r√©gression lin√©aire standard."
            },
            {
                question: "Pourquoi l'algorithme de backpropagation utilise-t-il le calcul du gradient par r√©tropropagation plut√¥t que par diff√©renciation num√©rique directe ?",
                options: [
                    "La r√©tropropagation est toujours plus pr√©cise math√©matiquement que la diff√©renciation num√©rique",
                    "La diff√©renciation num√©rique ne peut pas calculer les d√©riv√©es de fonctions d'activation non lin√©aires",
                    "La r√©tropropagation est computationnellement beaucoup plus efficace gr√¢ce √† la r√©utilisation des calculs interm√©diaires",
                    "La diff√©renciation num√©rique n√©cessite des √©chantillons suppl√©mentaires que la r√©tropropagation n'utilise pas"
                ],
                correctIndex: 2,
                explanation: "La diff√©renciation num√©rique directe (approximation par diff√©rences finies) n√©cessiterait au minimum 2N √©valuations du r√©seau pour calculer les d√©riv√©es partielles par rapport √† N param√®tres. La backpropagation, en revanche, calcule toutes ces d√©riv√©es en une seule passe arri√®re √† travers le r√©seau, gr√¢ce √† l'application r√©p√©t√©e de la r√®gle de cha√Æne et √† la r√©utilisation des gradients interm√©diaires. Cette optimisation algorithmique rend la backpropagation exponentiellement plus efficace en termes de calculs, surtout pour les r√©seaux avec millions de param√®tres."
            },
            {
                question: "Comment compl√©ter ce code pour calculer le biais et la variance dans la d√©composition de l'erreur de classification ?",
                options: [
                    "```python\n        model.fit(X_train_fold, y_train_fold)\n        # Pr√©dictions sur l'ensemble de validation\n        pred_proba = model.predict_proba(X_val_fold)\n        predictions.append(pred_proba)\n        actual.append(y_val_fold)\n\n    # Convertir en arrays numpy pour faciliter les calculs\n    predictions = np.array(predictions)\n    actual = np.array(actual)\n\n    # Calcul du biais\n    avg_pred = np.mean(predictions, axis=0)\n    bias = np.mean((avg_pred.argmax(axis=1) - actual.flatten()) ** 2)\n\n    # Calcul de la variance\n    variance = np.mean(np.var(predictions, axis=0))\n\n    return bias, variance\n```",
                    "```python\n        model.fit
        ];

        // Variables pour suivre l'√©tat du quiz
        let currentQuestionIndex = 0;
        let score = 0;
        let selectedOption = null;
        let answeredQuestions = new Array(questions.length).fill(false);

        // √âl√©ments DOM
        const questionContainer = document.getElementById('question-container');
        const prevBtn = document.getElementById('prev-btn');
        const checkBtn = document.getElementById('check-btn');
        const nextBtn = document.getElementById('next-btn');
        const feedback = document.getElementById('feedback');
        const explanation = document.getElementById('explanation');
        const resultsDiv = document.getElementById('results');
        const scoreDisplay = document.getElementById('score-display');
        const scoreMessage = document.getElementById('score-message');
        const restartBtn = document.getElementById('restart-btn');
        const progress = document.getElementById('progress');
        const quizContainer = document.getElementById('quiz');

        // Initialisation du quiz
        function initQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            selectedOption = null;
            answeredQuestions = new Array(questions.length).fill(false);
            
            showQuestion(currentQuestionIndex);
            updateProgressBar();
            
            quizContainer.style.display = 'block';
            resultsDiv.style.display = 'none';
            prevBtn.disabled = true;
            checkBtn.disabled = false;
            nextBtn.disabled = true;
        }

        // Afficher une question
        function showQuestion(index) {
            const question = questions[index];
            questionContainer.innerHTML = '';

            const questionDiv = document.createElement('div');
            questionDiv.className = 'question active';
            questionDiv.innerHTML = `<h3>Question ${index + 1}/${questions.length}</h3><p>${question.question}</p>`;

            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'options';

            question.options.forEach((option, optionIndex) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                optionDiv.innerHTML = option;

                // Si cette question a d√©j√† √©t√© r√©pondue, afficher le r√©sultat
                if (answeredQuestions[index]) {
                    if (optionIndex === question.correctIndex) {
                        optionDiv.classList.add('correct');
                    } else if (optionIndex === selectedOption && optionIndex !== question.correctIndex) {
                        optionDiv.classList.add('incorrect');
                    }
                } else {
                    // Sinon, ajouter les √©couteurs d'√©v√©nements pour la s√©lection
                    optionDiv.addEventListener('click', () => {
                        // Retirer la classe 'selected' de toutes les options
                        document.querySelectorAll('.option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        
                        // Ajouter la classe 'selected' √† l'option cliqu√©e
                        optionDiv.classList.add('selected');
                        selectedOption = optionIndex;
                        checkBtn.disabled = false;
                    });
                }

                optionsDiv.appendChild(optionDiv);
            });

            questionDiv.appendChild(optionsDiv);
            questionContainer.appendChild(questionDiv);

            // Mettre √† jour les boutons
            prevBtn.disabled = index === 0;
            
            if (answeredQuestions[index]) {
                checkBtn.disabled = true;
                nextBtn.disabled = index === questions.length - 1;
                explanation.innerHTML = question.explanation;
                explanation.style.display = 'block';
            } else {
                checkBtn.disabled = selectedOption === null;
                nextBtn.disabled = true;
                explanation.style.display = 'none';
            }
        }

        // V√©rifier la r√©ponse
        function checkAnswer() {
            if (selectedOption === null) return;

            const question = questions[currentQuestionIndex];
            const options = document.querySelectorAll('.option');

            // Marquer cette question comme r√©pondue
            answeredQuestions[currentQuestionIndex] = true;

            // Afficher les options correctes et incorrectes
            options.forEach((option, index) => {
                if (index === question.correctIndex) {
                    option.classList.add('correct');
                } else if (index === selectedOption && index !== question.correctIndex) {
                    option.classList.add('incorrect');
                }
            });

            // Mettre √† jour le score
            if (selectedOption === question.correctIndex) {
                score++;
                feedback.innerHTML = '<p>Correct! üëç</p>';
                feedback.style.backgroundColor = '#d4edda';
            } else {
                feedback.innerHTML = '<p>Incorrect! La bonne r√©ponse est : ' + question.options[question.correctIndex] + '</p>';
                feedback.style.backgroundColor = '#f8d7da';
            }

            // Afficher les explications
            explanation.innerHTML = question.explanation;
            explanation.style.display = 'block';
            feedback.style.display = 'block';

            // Mettre √† jour les boutons
            checkBtn.disabled = true;
            nextBtn.disabled = currentQuestionIndex === questions.length - 1;

            // Si c'est la derni√®re question et qu'elle est r√©pondue, afficher les r√©sultats
            if (currentQuestionIndex === questions.length - 1 && answeredQuestions.every(answered => answered)) {
                showResults();
            }
        }

        // Passer √† la question suivante
        function nextQuestion() {
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                selectedOption = null;
                feedback.style.display = 'none';
                showQuestion(currentQuestionIndex);
                updateProgressBar();
            }
        }

        // Revenir √† la question pr√©c√©dente
        function prevQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                selectedOption = null;
                feedback.style.display = 'none';
                showQuestion(currentQuestionIndex);
                updateProgressBar();
            }
        }

        // Afficher les r√©sultats
        function showResults() {
            quizContainer.style.display = 'none';
            resultsDiv.style.display = 'block';
            
            const percentage = Math.round((score / questions.length) * 100);
            scoreDisplay.innerHTML = `Vous avez obtenu ${score} sur ${questions.length} (${percentage}%)`;
            
            if (percentage >= 80) {
                scoreMessage.innerHTML = "Excellent! Vous ma√Ætrisez bien les concepts d'IA.";
            } else if (percentage >= 60) {
                scoreMessage.innerHTML = "Bon travail! Vous avez une bonne compr√©hension des concepts d'IA.";
            } else if (percentage >= 40) {
                scoreMessage.innerHTML = "Pas mal! Mais il y a encore place √† l'am√©lioration.";
            } else {
                scoreMessage.innerHTML = "Continuez √† √©tudier les concepts d'IA pour am√©liorer votre compr√©hension.";
            }
        }

        // Mettre √† jour la barre de progression
        function updateProgressBar() {
            const percentage = ((currentQuestionIndex + 1) / questions.length) * 100;
            progress.style.width = `${percentage}%`;
        }

        // √âcouteurs d'√©v√©nements pour les boutons
        prevBtn.addEventListener('click', prevQuestion);
        checkBtn.addEventListener('click', checkAnswer);
        nextBtn.addEventListener('click', nextQuestion);
        restartBtn.addEventListener('click', initQuiz);

        // Initialiser le quiz
        initQuiz();
    </script>
</body>
</html>